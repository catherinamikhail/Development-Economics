newdata <-data.frame(budget = 400000000, genre2 = "Comedy", release_year = 2026)
predict(lm5, newdata = newdata, interval = "predict")
#WRITE YOUR CODE HERE
library(ggplot2)
###Residuals vs log(budget)###
ggplot(movies3, aes(x = log(budget), y = residual)) +
geom_point() +
geom_hline(yintercept = 0, color = "red", linewidth = 1) +
xlim(-0.5, 20)
labs(
title = "Residuals vs log(budget)",
x = "log(budget)",
y = "Residuals"
) +
theme_minimal()
###Residuals vs Release Year###
ggplot(movies3, aes(x = release_year, y = residual)) +
geom_point() +
geom_hline(yintercept = 0, color = "red", linewidth = 1) +
labs(
title = "Residuals vs Release Year",
x = "Release Year",
y = "Residuals"
) +
theme_minimal()
###Residuals vs Genre2###
ggplot(movies3, aes(x = genre2, y = residual)) +
geom_boxplot() +
labs(
title = "Residuals by Genre",
x = "Genre",
y = "Residuals"
) +
theme_minimal()
###Residuals vs Fitted Values###
ggplot(data = data.frame(fitted = fitted(lm5), resid = resid(lm5)), aes(x = fitted, y = resid)) +
geom_point(color = "blue") +
geom_hline(yintercept = 0, color = "red") +
labs(title = "Residuals vs Fitted Values",
x = "Fitted Values",
y = "Residuals") +
theme_minimal()
#WRITE YOUR CODE HERE
movies3 <- movies3 %>%
filter(budget > 0) %>%
mutate(
PR = (revenue - budget) / budget,
english_dummy = ifelse(original_language == "en", 1, 0)
)
movies_lang <- na.omit(movies3)
lm_lang <- lm(PR ~ english_dummy, data = movies_lang)
summary(lm_lang)
knitr::opts_chunk$set(
echo = TRUE,
warning = FALSE,
message = FALSE,
results = 'markup'
)
# First we need to make sure that some packages (=places where e.g. commands are
#saved) are available, for this, we need to install them
#for this, we create a variable called check, (see in your Enviroment
#what value it takes after having run the line), it takes TRUE if the package is
#already installed and FALSE if not
check <- require('survey')
#next, we have a loop that has a condition (!check, this condition is TRUE if check is FALSE and FALSE if check is TRUE)
#i.e. if it is already installed, the loop will not do anything, if it is not instaled, it will install it
#Depending on your version, you might need to enter YES in the console to confirm that you want to install it
if(!check) {
install.packages('survey')
}
#just because it is installed does not mean that it is loaded into your current session (the one you run this file in), therefore we execute the following code
library(survey)
#to learn about the package
?survey
#now to the next package that will allow us to load the files we have easily into R
check <- require('readstata13')
#if not installed, install the package, this needs to be confirmed by typing in yes in the command console, after having run the following line
if(!check) {
install.packages('readstata13')
}
library('readstata13')
#to learn about the package
?readstata13
#some housekeeping
rm(check)
# now finally: Read in data
#for this: we create the filepath either per hand, see the line below,
#or we use the point-and-shoot-option (often easier if you donot feel comfortable with R or coding yet)
#statafile <- 'u:/interim files/Tanzania 2012.dta' #if you want to use this, delete the # at the beginning and type in the correct path
statafile2012 <- file.choose() #allows for clicking on it in a window, no need to have the path ready, click here on the file "Tanzania_2012.dta"
#load it
statafile2018 <- file.choose() #click here on the file "Tanzania_2018.dta"
tzdata2012 <- read.dta13(statafile2012,nonint.factors = T)
tzdata2018 = read.dta13(statafile2018,nonint.factors = T)
# Remove observations with missing data
tzdata2012 <- na.omit(tzdata2012)
tzdata2018 <- na.omit(tzdata2018)
#create population-weight (popwt) as a variable
tzdata2012$popwt <- with(tzdata2012,hhsize*hhweight)
tzdata2018$popwt <- with(tzdata2018,hhsize*hhweight)
#incorporate the surveydesign: for this, use the information about strata, weights and ID from the data
tzdesign2012 <- svydesign(id = ~CLUSTER, strata = ~STRATUM, weights = ~popwt, nest =T,  data = tzdata2012)
tzdesign2018 <- svydesign(id = ~CLUSTER, strata = ~STRATUM, weights = ~popwt, nest = T, data = tzdata2018)
#
#This is the end for the first round of the survey (either 2012 and 2018),
#now you will have to repeat the code for the other round, however, no need to load (or install) the packages again, good luck!
## National headcount for 2012
# First we determine which households are poor by looking at who's consumption is below the poverty line
tzdata2012$poor <- ifelse(tzdata2012$cons <= tzdata2012$povline, 1, 0)
# Then we calculate the amount of people those households represent
sum(tzdata2012$popwt * tzdata2012$poor, na.rm = TRUE)
# Then we calculate the headcount H = q/N
sum(tzdata2012$popwt * tzdata2012$poor, na.rm = TRUE)/sum(tzdata2012$popwt)
## National headcount for 2012
# First we determine which households are poor by looking at who's consumption is below the poverty line
tzdata2018$poor <- ifelse(tzdata2018$cons <= tzdata2018$povline, 1, 0)
# Then we calculate the amount of people those households represent
sum(tzdata2018$popwt * tzdata2018$poor, na.rm = TRUE)
# Then we calculate the headcount H = q/N
sum(tzdata2018$popwt * tzdata2018$poor, na.rm = TRUE)/sum(tzdata2018$popwt)
## National Poverty Gap for 2012
# First we determine the gap ratio = (poverty line - consumption)/poverty line for all people considered poor
tzdata2012$gapratio <- with(tzdata2012, (povline-cons)/povline * tzdata2012$poor)
# Then we calculate the poverty gap by PG= 1/N * (gap ratio * weighted population)
(1/sum(tzdata2012$popwt)) * sum(tzdata2012$gapratio * tzdata2012$popwt)
## National Poverty Gap for 2018
# First we determine the gap ratio = (poverty line - consumption)/poverty line for all people considered poor
tzdata2018$gapratio <- with(tzdata2018, (povline-cons)/povline * tzdata2018$poor)
# Then we calculate the poverty gap by PG= 1/N * (gap ratio * weighted population)
(1/sum(tzdata2018$popwt)) * sum(tzdata2018$gapratio * tzdata2018$popwt)
## National Poverty Gap for 2012
# First we determine the square gap ratio = (poverty line - consumption)/poverty)^2 / poverty line for all people considered poor
tzdata2012$squaregapratio <- with(tzdata2012, (sqrt((povline-cons)/povline * tzdata2012$poor)))
# Then we calculate the square poverty gap by PG= 1/N * (square gap ratio * weighted population)
(1/sum(tzdata2012$popwt)) * sum(tzdata2012$squaregapratio * tzdata2012$popwt)
## National Poverty Gap for 2018
# First we determine the square gap ratio = (poverty line - consumption)/poverty)^2 / line for all people considered poor
tzdata2018$squaregapratio <- with(tzdata2018, (sqrt((povline-cons)/povline * tzdata2018$poor)))
# Then we calculate the square poverty gap by PG= 1/N * (square gap ratio * weighted population)
(1/sum(tzdata2018$popwt)) * sum(tzdata2018$squaregapratio * tzdata2018$popwt)
# Headcount per area 2012
library(tidyverse)
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Headcount per area 2018
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Poverty gap per area 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Poverty gap per area 2012
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Squared poverty gap per area 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# Squared poverty gap per area 2018
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# Headcount per region 2012
tzdata2012 %>%
group_by(region) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Headcount per region 2018
tzdata2018 %>%
group_by(region) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Poverty gap per region 2012
tzdata2012 %>%
group_by(region) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Poverty gap per region 2018
tzdata2018 %>%
group_by(region) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Squared poverty gap per region 2012
tzdata2012 %>%
group_by(region) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# Squared poverty gap per region 2018
tzdata2018 %>%
group_by(region) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# stratum level contribution 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(contribution = ((sum(popwt * poor))/sum(popwt)) * 100)
# stratum level contribution 2018
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(contribution = ((sum(popwt * poor))/sum(popwt)) * 100)
# region level contribution 2012
tzdata2012 %>%
group_by(region) %>%
summarise(contribution = ((sum(popwt * poor))/sum(popwt)) * 100)
# region level contribution 2018
tzdata2018 %>%
group_by(region) %>%
summarise(contribution = ((sum(popwt * poor))/sum(popwt)) * 100)
knitr::opts_chunk$set(
echo = TRUE,
warning = FALSE,
message = FALSE,
results = 'markup'
)
# First we need to make sure that some packages (=places where e.g. commands are
#saved) are available, for this, we need to install them
#for this, we create a variable called check, (see in your Enviroment
#what value it takes after having run the line), it takes TRUE if the package is
#already installed and FALSE if not
check <- require('survey')
#next, we have a loop that has a condition (!check, this condition is TRUE if check is FALSE and FALSE if check is TRUE)
#i.e. if it is already installed, the loop will not do anything, if it is not instaled, it will install it
#Depending on your version, you might need to enter YES in the console to confirm that you want to install it
if(!check) {
install.packages('survey')
}
#just because it is installed does not mean that it is loaded into your current session (the one you run this file in), therefore we execute the following code
library(survey)
#to learn about the package
?survey
#now to the next package that will allow us to load the files we have easily into R
check <- require('readstata13')
#if not installed, install the package, this needs to be confirmed by typing in yes in the command console, after having run the following line
if(!check) {
install.packages('readstata13')
}
library('readstata13')
#to learn about the package
?readstata13
#some housekeeping
rm(check)
# now finally: Read in data
#for this: we create the filepath either per hand, see the line below,
#or we use the point-and-shoot-option (often easier if you donot feel comfortable with R or coding yet)
#statafile <- 'u:/interim files/Tanzania 2012.dta' #if you want to use this, delete the # at the beginning and type in the correct path
statafile2012 <- file.choose() #allows for clicking on it in a window, no need to have the path ready, click here on the file "Tanzania_2012.dta"
#load it
statafile2018 <- file.choose() #click here on the file "Tanzania_2018.dta"
tzdata2012 <- read.dta13(statafile2012,nonint.factors = T)
tzdata2018 = read.dta13(statafile2018,nonint.factors = T)
# Remove observations with missing data
tzdata2012 <- na.omit(tzdata2012)
tzdata2018 <- na.omit(tzdata2018)
#create population-weight (popwt) as a variable
tzdata2012$popwt <- with(tzdata2012,hhsize*hhweight)
tzdata2018$popwt <- with(tzdata2018,hhsize*hhweight)
#incorporate the surveydesign: for this, use the information about strata, weights and ID from the data
tzdesign2012 <- svydesign(id = ~CLUSTER, strata = ~STRATUM, weights = ~popwt, nest =T,  data = tzdata2012)
tzdesign2018 <- svydesign(id = ~CLUSTER, strata = ~STRATUM, weights = ~popwt, nest = T, data = tzdata2018)
#
#This is the end for the first round of the survey (either 2012 and 2018),
#now you will have to repeat the code for the other round, however, no need to load (or install) the packages again, good luck!
## National headcount for 2012
# First we determine which households are poor by looking at who's consumption is below the poverty line
tzdata2012$poor <- ifelse(tzdata2012$cons <= tzdata2012$povline, 1, 0)
# Then we calculate the amount of people those households represent
sum(tzdata2012$popwt * tzdata2012$poor, na.rm = TRUE)
# Then we calculate the headcount H = q/N
sum(tzdata2012$popwt * tzdata2012$poor, na.rm = TRUE)/sum(tzdata2012$popwt)
## National headcount for 2012
# First we determine which households are poor by looking at who's consumption is below the poverty line
tzdata2018$poor <- ifelse(tzdata2018$cons <= tzdata2018$povline, 1, 0)
# Then we calculate the amount of people those households represent
sum(tzdata2018$popwt * tzdata2018$poor, na.rm = TRUE)
# Then we calculate the headcount H = q/N
sum(tzdata2018$popwt * tzdata2018$poor, na.rm = TRUE)/sum(tzdata2018$popwt)
## National Poverty Gap for 2012
# First we determine the gap ratio = (poverty line - consumption)/poverty line for all people considered poor
tzdata2012$gapratio <- with(tzdata2012, (povline-cons)/povline * tzdata2012$poor)
# Then we calculate the poverty gap by PG= 1/N * (gap ratio * weighted population)
(1/sum(tzdata2012$popwt)) * sum(tzdata2012$gapratio * tzdata2012$popwt)
## National Poverty Gap for 2018
# First we determine the gap ratio = (poverty line - consumption)/poverty line for all people considered poor
tzdata2018$gapratio <- with(tzdata2018, (povline-cons)/povline * tzdata2018$poor)
# Then we calculate the poverty gap by PG= 1/N * (gap ratio * weighted population)
(1/sum(tzdata2018$popwt)) * sum(tzdata2018$gapratio * tzdata2018$popwt)
## National Poverty Gap for 2012
# First we determine the square gap ratio = (poverty line - consumption)/poverty)^2 / poverty line for all people considered poor
tzdata2012$squaregapratio <- with(tzdata2012, (sqrt((povline-cons)/povline * tzdata2012$poor)))
# Then we calculate the square poverty gap by PG= 1/N * (square gap ratio * weighted population)
(1/sum(tzdata2012$popwt)) * sum(tzdata2012$squaregapratio * tzdata2012$popwt)
## National Poverty Gap for 2018
# First we determine the square gap ratio = (poverty line - consumption)/poverty)^2 / line for all people considered poor
tzdata2018$squaregapratio <- with(tzdata2018, (sqrt((povline-cons)/povline * tzdata2018$poor)))
# Then we calculate the square poverty gap by PG= 1/N * (square gap ratio * weighted population)
(1/sum(tzdata2018$popwt)) * sum(tzdata2018$squaregapratio * tzdata2018$popwt)
# Headcount per area 2012
library(tidyverse)
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Headcount per area 2018
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Poverty gap per area 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Poverty gap per area 2012
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Squared poverty gap per area 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# Squared poverty gap per area 2018
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# Headcount per region 2012
tzdata2012 %>%
group_by(region) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Headcount per region 2018
tzdata2018 %>%
group_by(region) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Poverty gap per region 2012
tzdata2012 %>%
group_by(region) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Poverty gap per region 2018
tzdata2018 %>%
group_by(region) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Squared poverty gap per region 2012
tzdata2012 %>%
group_by(region) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# Squared poverty gap per region 2018
tzdata2018 %>%
group_by(region) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# stratum level contribution 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(contribution = ((sum(popwt * poor))/sum(popwt)) * 100)
# stratum level contribution 2018
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(contribution = ((sum(popwt * poor))/sum(popwt)) * 100)
# region level contribution 2012
tzdata2012 %>%
group_by(region) %>%
summarise(contribution = ((sum(popwt * poor))/sum(popwt)) * 100)
# region level contribution 2018
tzdata2018 %>%
group_by(region) %>%
summarise(contribution = ((sum(popwt * poor))/sum(popwt)) * 100)
setwd("~/Documents/GitHub/Development-Economics")
knitr::opts_chunk$set(
echo = TRUE,
warning = FALSE,
message = FALSE,
results = 'markup'
)
# First we need to make sure that some packages (=places where e.g. commands are
#saved) are available, for this, we need to install them
#for this, we create a variable called check, (see in your Enviroment
#what value it takes after having run the line), it takes TRUE if the package is
#already installed and FALSE if not
check <- require('survey')
#next, we have a loop that has a condition (!check, this condition is TRUE if check is FALSE and FALSE if check is TRUE)
#i.e. if it is already installed, the loop will not do anything, if it is not instaled, it will install it
#Depending on your version, you might need to enter YES in the console to confirm that you want to install it
if(!check) {
install.packages('survey')
}
#just because it is installed does not mean that it is loaded into your current session (the one you run this file in), therefore we execute the following code
library(survey)
#to learn about the package
?survey
#now to the next package that will allow us to load the files we have easily into R
check <- require('readstata13')
#if not installed, install the package, this needs to be confirmed by typing in yes in the command console, after having run the following line
if(!check) {
install.packages('readstata13')
}
library('readstata13')
#to learn about the package
?readstata13
#some housekeeping
rm(check)
# now finally: Read in data
#for this: we create the filepath either per hand, see the line below,
#or we use the point-and-shoot-option (often easier if you donot feel comfortable with R or coding yet)
#statafile <- 'u:/interim files/Tanzania 2012.dta' #if you want to use this, delete the # at the beginning and type in the correct path
statafile2012 <- file.choose() #allows for clicking on it in a window, no need to have the path ready, click here on the file "Tanzania_2012.dta"
#load it
statafile2018 <- file.choose() #click here on the file "Tanzania_2018.dta"
tzdata2012 <- read.dta13(statafile2012,nonint.factors = T)
tzdata2018 = read.dta13(statafile2018,nonint.factors = T)
# Remove observations with missing data
tzdata2012 <- na.omit(tzdata2012)
tzdata2018 <- na.omit(tzdata2018)
#create population-weight (popwt) as a variable
tzdata2012$popwt <- with(tzdata2012,hhsize*hhweight)
tzdata2018$popwt <- with(tzdata2018,hhsize*hhweight)
#incorporate the surveydesign: for this, use the information about strata, weights and ID from the data
tzdesign2012 <- svydesign(id = ~CLUSTER, strata = ~STRATUM, weights = ~popwt, nest =T,  data = tzdata2012)
tzdesign2018 <- svydesign(id = ~CLUSTER, strata = ~STRATUM, weights = ~popwt, nest = T, data = tzdata2018)
#
#This is the end for the first round of the survey (either 2012 and 2018),
#now you will have to repeat the code for the other round, however, no need to load (or install) the packages again, good luck!
## National headcount for 2012
# First we determine which households are poor by looking at who's consumption is below the poverty line
tzdata2012$poor <- ifelse(tzdata2012$cons <= tzdata2012$povline, 1, 0)
# Then we calculate the amount of people those households represent
sum(tzdata2012$popwt * tzdata2012$poor, na.rm = TRUE)
# Then we calculate the headcount H = q/N
sum(tzdata2012$popwt * tzdata2012$poor, na.rm = TRUE)/sum(tzdata2012$popwt)
## National headcount for 2012
# First we determine which households are poor by looking at who's consumption is below the poverty line
tzdata2018$poor <- ifelse(tzdata2018$cons <= tzdata2018$povline, 1, 0)
# Then we calculate the amount of people those households represent
sum(tzdata2018$popwt * tzdata2018$poor, na.rm = TRUE)
# Then we calculate the headcount H = q/N
sum(tzdata2018$popwt * tzdata2018$poor, na.rm = TRUE)/sum(tzdata2018$popwt)
## National Poverty Gap for 2012
# First we determine the gap ratio = (poverty line - consumption)/poverty line for all people considered poor
tzdata2012$gapratio <- with(tzdata2012, (povline-cons)/povline * tzdata2012$poor)
# Then we calculate the poverty gap by PG= 1/N * (gap ratio * weighted population)
(1/sum(tzdata2012$popwt)) * sum(tzdata2012$gapratio * tzdata2012$popwt)
## National Poverty Gap for 2018
# First we determine the gap ratio = (poverty line - consumption)/poverty line for all people considered poor
tzdata2018$gapratio <- with(tzdata2018, (povline-cons)/povline * tzdata2018$poor)
# Then we calculate the poverty gap by PG= 1/N * (gap ratio * weighted population)
(1/sum(tzdata2018$popwt)) * sum(tzdata2018$gapratio * tzdata2018$popwt)
## National Poverty Gap for 2012
# First we determine the square gap ratio = (poverty line - consumption)/poverty)^2 / poverty line for all people considered poor
tzdata2012$squaregapratio <- with(tzdata2012, (sqrt((povline-cons)/povline * tzdata2012$poor)))
# Then we calculate the square poverty gap by PG= 1/N * (square gap ratio * weighted population)
(1/sum(tzdata2012$popwt)) * sum(tzdata2012$squaregapratio * tzdata2012$popwt)
## National Poverty Gap for 2018
# First we determine the square gap ratio = (poverty line - consumption)/poverty)^2 / line for all people considered poor
tzdata2018$squaregapratio <- with(tzdata2018, (sqrt((povline-cons)/povline * tzdata2018$poor)))
# Then we calculate the square poverty gap by PG= 1/N * (square gap ratio * weighted population)
(1/sum(tzdata2018$popwt)) * sum(tzdata2018$squaregapratio * tzdata2018$popwt)
# Headcount per area 2012
library(tidyverse)
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Headcount per area 2018
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Poverty gap per area 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Poverty gap per area 2012
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Squared poverty gap per area 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# Squared poverty gap per area 2018
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# Headcount per region 2012
tzdata2012 %>%
group_by(region) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Headcount per region 2018
tzdata2018 %>%
group_by(region) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Poverty gap per region 2012
tzdata2012 %>%
group_by(region) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Poverty gap per region 2018
tzdata2018 %>%
group_by(region) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Squared poverty gap per region 2012
tzdata2012 %>%
group_by(region) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# Squared poverty gap per region 2018
tzdata2018 %>%
group_by(region) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# stratum level contribution 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(contribution = ((sum(popwt * poor))/sum(popwt)) * 100)
# stratum level contribution 2018
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(contribution = ((sum(popwt * poor))/sum(popwt)) * 100)
# region level contribution 2012
tzdata2012 %>%
group_by(region) %>%
summarise(contribution = ((sum(popwt * poor))/sum(popwt)) * 100)
# region level contribution 2018
tzdata2018 %>%
group_by(region) %>%
summarise(contribution = ((sum(popwt * poor))/sum(popwt)) * 100)
