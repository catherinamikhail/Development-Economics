# Remove any missing data
keep_cases <- !with(tzdata2018,
is.na(cons) | is.na(STRATUM) | is.na(CLUSTER) | is.na(hhsize) | is.na(hhweight)
)
tzdata2018 <- tzdata2018[keep_cases, ]
rm(keep_cases)
# Define new variables
tzdata2018$popwt <- with(tzdata2018, hhsize * hhweight)
# Set survey design parameters
tzdesign2 <- svydesign(
id = ~CLUSTER,
strata = ~STRATUM,
weights = ~popwt,
data = tzdata2018,
nest = TRUE
)
## National headcount for 2012
# First we determine which households are poor by looking at who's consumption is below the poverty line
tzdata2012$poor <- ifelse(tzdata2012$cons <= tzdata2012$povline, 1, 0)
# Then we calculate the amount of people those households represent
sum(tzdata2012$popwt * tzdata2012$poor, na.rm = TRUE)
# Then we calculate the headcount H = q/N
sum(tzdata2012$popwt * tzdata2012$poor, na.rm = TRUE)/sum(tzdata2012$popwt)
## National headcount for 2012
# First we determine which households are poor by looking at who's consumption is below the poverty line
tzdata2018$poor <- ifelse(tzdata2018$cons <= tzdata2018$povline, 1, 0)
# Then we calculate the amount of people those households represent
sum(tzdata2018$popwt * tzdata2018$poor, na.rm = TRUE)
# Then we calculate the headcount H = q/N
sum(tzdata2018$popwt * tzdata2018$poor, na.rm = TRUE)/sum(tzdata2018$popwt)
## National Poverty Gap for 2012
# First we determine the gap ratio = (poverty line - consumption)/poverty line for all people considered poor
tzdata2012$gapratio <- with(tzdata2012, (povline-cons)/povline * tzdata2012$poor)
# Then we calculate the poverty gap by PG= 1/N * (gap ratio * weighted population)
(1/sum(tzdata2012$popwt)) * sum(tzdata2012$gapratio * tzdata2012$popwt)
## National Poverty Gap for 2018
# First we determine the gap ratio = (poverty line - consumption)/poverty line for all people considered poor
tzdata2018$gapratio <- with(tzdata2018, (povline-cons)/povline * tzdata2018$poor)
# Then we calculate the poverty gap by PG= 1/N * (gap ratio * weighted population)
(1/sum(tzdata2018$popwt)) * sum(tzdata2018$gapratio * tzdata2018$popwt)
## National Poverty Gap for 2012
# First we determine the square gap ratio = (poverty line - consumption)/poverty)^2 / poverty line for all people considered poor
tzdata2012$squaregapratio <- with(tzdata2012, (sqrt((povline-cons)/povline * tzdata2012$poor)))
# Then we calculate the square poverty gap by PG= 1/N * (square gap ratio * weighted population)
(1/sum(tzdata2012$popwt)) * sum(tzdata2012$squaregapratio * tzdata2012$popwt)
## National Poverty Gap for 2018
# First we determine the square gap ratio = (poverty line - consumption)/poverty)^2 / line for all people considered poor
tzdata2018$squaregapratio <- with(tzdata2018, (sqrt((povline-cons)/povline * tzdata2018$poor)))
# Then we calculate the square poverty gap by PG= 1/N * (square gap ratio * weighted population)
(1/sum(tzdata2018$popwt)) * sum(tzdata2018$squaregapratio * tzdata2018$popwt)
# Headcount per area 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Headcount per area 2018
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Poverty gap per area 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Poverty gap per area 2012
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Squared poverty gap per area 2012
tzdata2012 %>%
group_by(STRATUM) %>%
(1/sum(popwt)) * sum(squaregapratio * popwt)
# Squared poverty gap per area 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# Squared poverty gap per area 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# Squared poverty gap per area 2018
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
knitr::opts_chunk$set(include = FALSE)
#Set up packages
library(dplyr)
# Set up the datafiles for 2012
# Use the 'survey' package. Install it if necessary
check <- require('survey')
if(!check) {
install.packages('survey')
library(survey)
}
rm(check)
# Use the 'readstata13' package to read Stata's data files. Install it if necessary
check <- require('readstata13')
if(!check) {
install.packages('readstata13')
library(readstata13)
}
rm(check)
# Read in data
# statafile <- 'u:/interim files/Tanzania 2012.dta'
statafile1 <- '~/Documents/GitHub/Development-Economics/Tanzania_2012.dta'
tzdata2012 <- read.dta13(statafile1, nonint.factors = TRUE)
# Remove any missing data
keep_cases <- !with(tzdata2012,
is.na(cons) | is.na(STRATUM) | is.na(CLUSTER) | is.na(hhsize) | is.na(hhweight)
)
tzdata2012 <- tzdata2012[keep_cases, ]
rm(keep_cases)
# Define new variables
tzdata2012$popwt <- with(tzdata2012, hhsize * hhweight)
# Set survey design parameters
tzdesign1 <- svydesign(
id = ~CLUSTER,
strata = ~STRATUM,
weights = ~popwt,
data = tzdata2012
)
# Set up the datafiles for 2018
# Use the 'survey' package. Install it if necessary
check <- require('survey')
if(!check) {
install.packages('survey')
library(survey)
}
rm(check)
# Use the 'readstata13' package to read Stata's data files. Install it if necessary
check <- require('readstata13')
if(!check) {
install.packages('readstata13')
library(readstata13)
}
rm(check)
# Read in data
# statafile <- 'u:/interim files/Tanzania 2012.dta'
statafile2 <- '~/Documents/GitHub/Development-Economics/Tanzania_2018.dta'
tzdata2018 <- read.dta13(statafile2, nonint.factors = TRUE)
# Remove any missing data
keep_cases <- !with(tzdata2018,
is.na(cons) | is.na(STRATUM) | is.na(CLUSTER) | is.na(hhsize) | is.na(hhweight)
)
tzdata2018 <- tzdata2018[keep_cases, ]
rm(keep_cases)
# Define new variables
tzdata2018$popwt <- with(tzdata2018, hhsize * hhweight)
# Set survey design parameters
tzdesign2 <- svydesign(
id = ~CLUSTER,
strata = ~STRATUM,
weights = ~popwt,
data = tzdata2018,
nest = TRUE
)
## National headcount for 2012
# First we determine which households are poor by looking at who's consumption is below the poverty line
tzdata2012$poor <- ifelse(tzdata2012$cons <= tzdata2012$povline, 1, 0)
# Then we calculate the amount of people those households represent
sum(tzdata2012$popwt * tzdata2012$poor, na.rm = TRUE)
# Then we calculate the headcount H = q/N
sum(tzdata2012$popwt * tzdata2012$poor, na.rm = TRUE)/sum(tzdata2012$popwt)
## National headcount for 2012
# First we determine which households are poor by looking at who's consumption is below the poverty line
tzdata2018$poor <- ifelse(tzdata2018$cons <= tzdata2018$povline, 1, 0)
# Then we calculate the amount of people those households represent
sum(tzdata2018$popwt * tzdata2018$poor, na.rm = TRUE)
# Then we calculate the headcount H = q/N
sum(tzdata2018$popwt * tzdata2018$poor, na.rm = TRUE)/sum(tzdata2018$popwt)
## National Poverty Gap for 2012
# First we determine the gap ratio = (poverty line - consumption)/poverty line for all people considered poor
tzdata2012$gapratio <- with(tzdata2012, (povline-cons)/povline * tzdata2012$poor)
# Then we calculate the poverty gap by PG= 1/N * (gap ratio * weighted population)
(1/sum(tzdata2012$popwt)) * sum(tzdata2012$gapratio * tzdata2012$popwt)
## National Poverty Gap for 2018
# First we determine the gap ratio = (poverty line - consumption)/poverty line for all people considered poor
tzdata2018$gapratio <- with(tzdata2018, (povline-cons)/povline * tzdata2018$poor)
# Then we calculate the poverty gap by PG= 1/N * (gap ratio * weighted population)
(1/sum(tzdata2018$popwt)) * sum(tzdata2018$gapratio * tzdata2018$popwt)
## National Poverty Gap for 2012
# First we determine the square gap ratio = (poverty line - consumption)/poverty)^2 / poverty line for all people considered poor
tzdata2012$squaregapratio <- with(tzdata2012, (sqrt((povline-cons)/povline * tzdata2012$poor)))
# Then we calculate the square poverty gap by PG= 1/N * (square gap ratio * weighted population)
(1/sum(tzdata2012$popwt)) * sum(tzdata2012$squaregapratio * tzdata2012$popwt)
## National Poverty Gap for 2018
# First we determine the square gap ratio = (poverty line - consumption)/poverty)^2 / line for all people considered poor
tzdata2018$squaregapratio <- with(tzdata2018, (sqrt((povline-cons)/povline * tzdata2018$poor)))
# Then we calculate the square poverty gap by PG= 1/N * (square gap ratio * weighted population)
(1/sum(tzdata2018$popwt)) * sum(tzdata2018$squaregapratio * tzdata2018$popwt)
knitr::opts_chunk$set(include = FALSE)
#Set up packages
library(dplyr)
# Set up the datafiles for 2012
# Use the 'survey' package. Install it if necessary
check <- require('survey')
if(!check) {
install.packages('survey')
library(survey)
}
rm(check)
# Use the 'readstata13' package to read Stata's data files. Install it if necessary
check <- require('readstata13')
if(!check) {
install.packages('readstata13')
library(readstata13)
}
rm(check)
# Read in data
# statafile <- 'u:/interim files/Tanzania 2012.dta'
statafile1 <- '~/Documents/GitHub/Development-Economics/Tanzania_2012.dta'
tzdata2012 <- read.dta13(statafile1, nonint.factors = TRUE)
# Remove any missing data
keep_cases <- !with(tzdata2012,
is.na(cons) | is.na(STRATUM) | is.na(CLUSTER) | is.na(hhsize) | is.na(hhweight)
)
tzdata2012 <- tzdata2012[keep_cases, ]
rm(keep_cases)
# Define new variables
tzdata2012$popwt <- with(tzdata2012, hhsize * hhweight)
# Set survey design parameters
tzdesign1 <- svydesign(
id = ~CLUSTER,
strata = ~STRATUM,
weights = ~popwt,
data = tzdata2012
)
# Set up the datafiles for 2018
# Use the 'survey' package. Install it if necessary
check <- require('survey')
if(!check) {
install.packages('survey')
library(survey)
}
rm(check)
# Use the 'readstata13' package to read Stata's data files. Install it if necessary
check <- require('readstata13')
if(!check) {
install.packages('readstata13')
library(readstata13)
}
rm(check)
# Read in data
# statafile <- 'u:/interim files/Tanzania 2012.dta'
statafile2 <- '~/Documents/GitHub/Development-Economics/Tanzania_2018.dta'
tzdata2018 <- read.dta13(statafile2, nonint.factors = TRUE)
# Remove any missing data
keep_cases <- !with(tzdata2018,
is.na(cons) | is.na(STRATUM) | is.na(CLUSTER) | is.na(hhsize) | is.na(hhweight)
)
tzdata2018 <- tzdata2018[keep_cases, ]
rm(keep_cases)
# Define new variables
tzdata2018$popwt <- with(tzdata2018, hhsize * hhweight)
# Set survey design parameters
tzdesign2 <- svydesign(
id = ~CLUSTER,
strata = ~STRATUM,
weights = ~popwt,
data = tzdata2018,
nest = TRUE
)
## National headcount for 2012
# First we determine which households are poor by looking at who's consumption is below the poverty line
tzdata2012$poor <- ifelse(tzdata2012$cons <= tzdata2012$povline, 1, 0)
# Then we calculate the amount of people those households represent
sum(tzdata2012$popwt * tzdata2012$poor, na.rm = TRUE)
# Then we calculate the headcount H = q/N
sum(tzdata2012$popwt * tzdata2012$poor, na.rm = TRUE)/sum(tzdata2012$popwt)
## National headcount for 2012
# First we determine which households are poor by looking at who's consumption is below the poverty line
tzdata2018$poor <- ifelse(tzdata2018$cons <= tzdata2018$povline, 1, 0)
# Then we calculate the amount of people those households represent
sum(tzdata2018$popwt * tzdata2018$poor, na.rm = TRUE)
# Then we calculate the headcount H = q/N
sum(tzdata2018$popwt * tzdata2018$poor, na.rm = TRUE)/sum(tzdata2018$popwt)
## National Poverty Gap for 2012
# First we determine the gap ratio = (poverty line - consumption)/poverty line for all people considered poor
tzdata2012$gapratio <- with(tzdata2012, (povline-cons)/povline * tzdata2012$poor)
# Then we calculate the poverty gap by PG= 1/N * (gap ratio * weighted population)
(1/sum(tzdata2012$popwt)) * sum(tzdata2012$gapratio * tzdata2012$popwt)
## National Poverty Gap for 2018
# First we determine the gap ratio = (poverty line - consumption)/poverty line for all people considered poor
tzdata2018$gapratio <- with(tzdata2018, (povline-cons)/povline * tzdata2018$poor)
# Then we calculate the poverty gap by PG= 1/N * (gap ratio * weighted population)
(1/sum(tzdata2018$popwt)) * sum(tzdata2018$gapratio * tzdata2018$popwt)
## National Poverty Gap for 2012
# First we determine the square gap ratio = (poverty line - consumption)/poverty)^2 / poverty line for all people considered poor
tzdata2012$squaregapratio <- with(tzdata2012, (sqrt((povline-cons)/povline * tzdata2012$poor)))
# Then we calculate the square poverty gap by PG= 1/N * (square gap ratio * weighted population)
(1/sum(tzdata2012$popwt)) * sum(tzdata2012$squaregapratio * tzdata2012$popwt)
## National Poverty Gap for 2018
# First we determine the square gap ratio = (poverty line - consumption)/poverty)^2 / line for all people considered poor
tzdata2018$squaregapratio <- with(tzdata2018, (sqrt((povline-cons)/povline * tzdata2018$poor)))
# Then we calculate the square poverty gap by PG= 1/N * (square gap ratio * weighted population)
(1/sum(tzdata2018$popwt)) * sum(tzdata2018$squaregapratio * tzdata2018$popwt)
# Headcount per area 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Headcount per area 2018
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Poverty gap per area 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Poverty gap per area 2012
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Squared poverty gap per area 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# Squared poverty gap per area 2018
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# Headcount per region 2012
tzdata2012 %>%
group_by(region) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Headcount per region 2018
tzdata2018 %>%
group_by(region) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Poverty gap per region 2012
tzdata2012 %>%
group_by(region) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Poverty gap per region 2012
tzdata2018 %>%
group_by(region) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Squared poverty gap per region 2012
tzdata2012 %>%
group_by(region) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# Squared poverty gap per region 2018
tzdata2018 %>%
group_by(region) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
knitr::opts_chunk$set(include = FALSE)
#Set up packages
library(dplyr)
# Set up the datafiles for 2012
# Use the 'survey' package. Install it if necessary
check <- require('survey')
if(!check) {
install.packages('survey')
library(survey)
}
rm(check)
# Use the 'readstata13' package to read Stata's data files. Install it if necessary
check <- require('readstata13')
if(!check) {
install.packages('readstata13')
library(readstata13)
}
rm(check)
# Read in data
# statafile <- 'u:/interim files/Tanzania 2012.dta'
statafile1 <- '~/Documents/GitHub/Development-Economics/Tanzania_2012.dta'
tzdata2012 <- read.dta13(statafile1, nonint.factors = TRUE)
# Remove any missing data
keep_cases <- !with(tzdata2012,
is.na(cons) | is.na(STRATUM) | is.na(CLUSTER) | is.na(hhsize) | is.na(hhweight)
)
tzdata2012 <- tzdata2012[keep_cases, ]
rm(keep_cases)
# Define new variables
tzdata2012$popwt <- with(tzdata2012, hhsize * hhweight)
# Set survey design parameters
tzdesign1 <- svydesign(
id = ~CLUSTER,
strata = ~STRATUM,
weights = ~popwt,
data = tzdata2012
)
# Set up the datafiles for 2018
# Use the 'survey' package. Install it if necessary
check <- require('survey')
if(!check) {
install.packages('survey')
library(survey)
}
rm(check)
# Use the 'readstata13' package to read Stata's data files. Install it if necessary
check <- require('readstata13')
if(!check) {
install.packages('readstata13')
library(readstata13)
}
rm(check)
# Read in data
# statafile <- 'u:/interim files/Tanzania 2012.dta'
statafile2 <- '~/Documents/GitHub/Development-Economics/Tanzania_2018.dta'
tzdata2018 <- read.dta13(statafile2, nonint.factors = TRUE)
# Remove any missing data
keep_cases <- !with(tzdata2018,
is.na(cons) | is.na(STRATUM) | is.na(CLUSTER) | is.na(hhsize) | is.na(hhweight)
)
tzdata2018 <- tzdata2018[keep_cases, ]
rm(keep_cases)
# Define new variables
tzdata2018$popwt <- with(tzdata2018, hhsize * hhweight)
# Set survey design parameters
tzdesign2 <- svydesign(
id = ~CLUSTER,
strata = ~STRATUM,
weights = ~popwt,
data = tzdata2018,
nest = TRUE
)
## National headcount for 2012
# First we determine which households are poor by looking at who's consumption is below the poverty line
tzdata2012$poor <- ifelse(tzdata2012$cons <= tzdata2012$povline, 1, 0)
# Then we calculate the amount of people those households represent
sum(tzdata2012$popwt * tzdata2012$poor, na.rm = TRUE)
# Then we calculate the headcount H = q/N
sum(tzdata2012$popwt * tzdata2012$poor, na.rm = TRUE)/sum(tzdata2012$popwt)
## National headcount for 2012
# First we determine which households are poor by looking at who's consumption is below the poverty line
tzdata2018$poor <- ifelse(tzdata2018$cons <= tzdata2018$povline, 1, 0)
# Then we calculate the amount of people those households represent
sum(tzdata2018$popwt * tzdata2018$poor, na.rm = TRUE)
# Then we calculate the headcount H = q/N
sum(tzdata2018$popwt * tzdata2018$poor, na.rm = TRUE)/sum(tzdata2018$popwt)
## National Poverty Gap for 2012
# First we determine the gap ratio = (poverty line - consumption)/poverty line for all people considered poor
tzdata2012$gapratio <- with(tzdata2012, (povline-cons)/povline * tzdata2012$poor)
# Then we calculate the poverty gap by PG= 1/N * (gap ratio * weighted population)
(1/sum(tzdata2012$popwt)) * sum(tzdata2012$gapratio * tzdata2012$popwt)
## National Poverty Gap for 2018
# First we determine the gap ratio = (poverty line - consumption)/poverty line for all people considered poor
tzdata2018$gapratio <- with(tzdata2018, (povline-cons)/povline * tzdata2018$poor)
# Then we calculate the poverty gap by PG= 1/N * (gap ratio * weighted population)
(1/sum(tzdata2018$popwt)) * sum(tzdata2018$gapratio * tzdata2018$popwt)
## National Poverty Gap for 2012
# First we determine the square gap ratio = (poverty line - consumption)/poverty)^2 / poverty line for all people considered poor
tzdata2012$squaregapratio <- with(tzdata2012, (sqrt((povline-cons)/povline * tzdata2012$poor)))
# Then we calculate the square poverty gap by PG= 1/N * (square gap ratio * weighted population)
(1/sum(tzdata2012$popwt)) * sum(tzdata2012$squaregapratio * tzdata2012$popwt)
## National Poverty Gap for 2018
# First we determine the square gap ratio = (poverty line - consumption)/poverty)^2 / line for all people considered poor
tzdata2018$squaregapratio <- with(tzdata2018, (sqrt((povline-cons)/povline * tzdata2018$poor)))
# Then we calculate the square poverty gap by PG= 1/N * (square gap ratio * weighted population)
(1/sum(tzdata2018$popwt)) * sum(tzdata2018$squaregapratio * tzdata2018$popwt)
# Headcount per area 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Headcount per area 2018
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Poverty gap per area 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Poverty gap per area 2012
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Squared poverty gap per area 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# Squared poverty gap per area 2018
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# Headcount per region 2012
tzdata2012 %>%
group_by(region) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Headcount per region 2018
tzdata2018 %>%
group_by(region) %>%
summarise(headcount = sum(popwt * poor, na.rm = TRUE)/sum(popwt))
# Poverty gap per region 2012
tzdata2012 %>%
group_by(region) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Poverty gap per region 2012
tzdata2018 %>%
group_by(region) %>%
summarise(poverty_gap = (1/sum(popwt)) * sum(gapratio * popwt))
# Squared poverty gap per region 2012
tzdata2012 %>%
group_by(region) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# Squared poverty gap per region 2018
tzdata2018 %>%
group_by(region) %>%
summarise(squared_poverty_gap = (1/sum(popwt)) * sum(squaregapratio * popwt))
# stratum level contribution 2012
tzdata2012 %>%
group_by(STRATUM) %>%
summarise(contribution = ((sum(popwt * poor))/sum(popwt)) * 100)
# stratum level contribution 2018
tzdata2018 %>%
group_by(STRATUM) %>%
summarise(contribution = ((sum(popwt * poor))/sum(popwt)) * 100)
# region level contribution 2012
tzdata2012 %>%
group_by(region) %>%
summarise(contribution = ((sum(popwt * poor))/sum(popwt)) * 100)
# region level contribution 2018
tzdata2018 %>%
group_by(region) %>%
summarise(contribution = ((sum(popwt * poor))/sum(popwt)) * 100)
